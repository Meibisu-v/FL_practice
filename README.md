## Условие задачи №15

Дано регулярное выражение  и слово ```u```, состоящее из букв a, b, c. Надо найти длину самого длинного префикса ```u```, являющегося также префиксом некоторого слова в языке ```L```, задаваемым регулярным выражением.
## Что лежит в структуре ```Union```

Мы посимвольно смотрим на регулярное выражение в обратной польской записи и кладем в стек какую-то информацию про это подвыражение. Каждое подвыражение задает язык ```L```, давайте хранить все подстроки ```u```, лежащие в ```L``` в массиве ```substrings``` и все подстроки ```u``` являющиеся префиксами строк лежащих в ```L``` в массиве ```prefixes```. Также будем хранить ответ на задачу в атрибуте ```maxCommonPrefix``` и лежит ли пустое слово в ```L``` в атрибуте ```voidWord```. У нас получилась структура данных, занимающая O(u.size()^2) места, так как подстроки мы храним в двумерном массиве из ```bool```.

## Реализация операций

### Cложение

Нам достаточно сделать логическое или, а это делается за O(u.size()^2)

### Умножение

Нам нужно сконкатенировать слова лежащие в обоих языках, мы это делаем перебирая: 
 
1)начало 1ого слова
 
2)конец 1ого слова == начало второго слова
 
3)конец 2ого слова
 
Итого это реализуется за O(u.size()^3)

### Звезда Клини

В полученном языке лежит пустое слово. Чтобы пересчитать подстроки мы можем воспользоваться немного измененным алгоритмом Флойда, а префиксы это слова лежащее в языке + старый префикс. Итого это работает за O(u.size()^3)

## Общая асимптотика
Каждая операция работает в худшем случае за куб, следовательно, все вместе работает не более чем за O(u.size()^3)

## Тесты из условия

У меня получились регулярные выражения 

((a + b)c + a(ba)*(b + ac))* тут есть слово abacbc

(acb + b(abc)*(ab + ba))*a тут есть слово acbacba

Получается, что в обоих тестах ответ 5, а не 4, как сказано в условии
